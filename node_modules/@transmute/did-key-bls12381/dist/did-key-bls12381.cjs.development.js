'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bs58 = _interopDefault(require('bs58'));
var bbsSignatures = require('@mattrglobal/bbs-signatures');
var base64url = _interopDefault(require('base64url'));
var mattr = require('@mattrglobal/bls12381-key-pair');

var generateKeyPairs = function generateKeyPairs() {
  try {
    return Promise.resolve(bbsSignatures.generateBls12381G1KeyPair()).then(function (g1) {
      return Promise.resolve(bbsSignatures.generateBls12381G2KeyPair()).then(function (g2) {
        var bls12381G1KeyPair = {
          id: '',
          type: 'Bls12381G1Key2020',
          controller: '',
          publicKeyBase58: bs58.encode(g1.publicKey),
          privateKeyBase58: bs58.encode(g1.secretKey)
        };
        var bls12381G2KeyPair = {
          id: '',
          type: 'Bls12381G2Key2020',
          controller: '',
          publicKeyBase58: bs58.encode(g2.publicKey),
          privateKeyBase58: bs58.encode(g2.secretKey)
        };
        return {
          bls12381G1KeyPair: bls12381G1KeyPair,
          bls12381G2KeyPair: bls12381G2KeyPair
        };
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// Pulled from https://github.com/mattrglobal/bls12381-key-pair
// License is Apache-2.0

/**
 * z represents the multibase encoding scheme of base58 encoding
 * @see https://github.com/multiformats/multibase/blob/master/multibase.csv#L18
 * @ignore
 */
var MULTIBASE_ENCODED_BASE58_IDENTIFIER = 'z';
/**
 * 0x01 indicates the end of the leading bytes according to variable integer spec
 * @see https://github.com/multiformats/multicodec
 * @ignore
 */

var VARIABLE_INTEGER_TRAILING_BYTE = 0x01;
/**
 * 0xea indicates a BLS 12-381 G1 public key
 *
 */

var BLS12381G1_MULTICODEC_IDENTIFIER = 0xea;
/**
 * 0xeb indicates a BLS 12-381 G2 public key
 *
 */

var BLS12381G2_MULTICODEC_IDENTIFIER = 0xeb;
/**
 * 0xee indicates a BLS 12-381 G1 concat with BLS 12-381 G2
 *
 */

var BLS12381G1ANDG2_MULTICODEC_IDENTIFIER = 0xee;

var BlsCurveName;

(function (BlsCurveName) {
  BlsCurveName["G1"] = "BLS12381_G1";
  BlsCurveName["G2"] = "BLS12381_G2";
})(BlsCurveName || (BlsCurveName = {}));

var curveMap = {
  Bls12381G1Key2020: BlsCurveName.G1,
  Bls12381G2Key2020: BlsCurveName.G2
};
var toJsonWebKeyPair = function toJsonWebKeyPair(keypair) {
  var jsonWebKeyPair = {
    id: keypair.id,
    controller: keypair.controller,
    type: 'JsonWebKey2020',
    publicKeyJwk: {
      kty: 'EC',
      crv: curveMap[keypair.type],
      x: base64url.encode(bs58.decode(keypair.publicKeyBase58))
    }
  };

  if (keypair.privateKeyBase58) {
    jsonWebKeyPair.privateKeyJwk = {
      kty: 'EC',
      crv: curveMap[keypair.type],
      x: base64url.encode(bs58.decode(keypair.publicKeyBase58)),
      d: base64url.encode(bs58.decode(keypair.privateKeyBase58))
    };
  }

  return jsonWebKeyPair;
};

var fingerprintToJsonWebKeyPair = function fingerprintToJsonWebKeyPair(fingerprint) {
  if (fingerprint[0] !== 'z') {
    throw new Error('base58 encoded fingerprint must start with "z"');
  }

  var buffer = bs58.decode(fingerprint.substring(1));

  if (buffer[0] === BLS12381G1_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {
    var kp = toJsonWebKeyPair({
      type: 'Bls12381G1Key2020',
      publicKeyBase58: bs58.encode(buffer.slice(2))
    });
    return {
      bls12381G1KeyPair: _extends({}, kp, {
        id: '#' + fingerprint,
        controller: "did:key:" + fingerprint
      })
    };
  }

  if (buffer[0] === BLS12381G2_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {
    var _kp = toJsonWebKeyPair({
      type: 'Bls12381G2Key2020',
      publicKeyBase58: bs58.encode(buffer.slice(2))
    });

    return {
      bls12381G2KeyPair: _extends({}, _kp, {
        id: '#' + fingerprint,
        controller: "did:key:" + fingerprint
      })
    };
  }

  if (buffer[0] === BLS12381G1ANDG2_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {
    var g1 = toJsonWebKeyPair({
      type: 'Bls12381G1Key2020',
      publicKeyBase58: bs58.encode(buffer.slice(2, 50))
    });
    var g2 = toJsonWebKeyPair({
      type: 'Bls12381G2Key2020',
      publicKeyBase58: bs58.encode(buffer.slice(50))
    });
    return {
      bls12381G1KeyPair: _extends({}, g1, {
        id: '#' + fingerprint,
        controller: "did:key:" + fingerprint
      }),
      bls12381G2KeyPair: _extends({}, g2, {
        id: '#' + fingerprint,
        controller: "did:key:" + fingerprint
      })
    };
  }

  throw new Error('unsupported fingerprint is not g1, g2 or g1 and g2.');
};

var _curveToMulticodecMap;
var curveToMulticodecMap = (_curveToMulticodecMap = {}, _curveToMulticodecMap[BlsCurveName.G1] = BLS12381G1_MULTICODEC_IDENTIFIER, _curveToMulticodecMap[BlsCurveName.G2] = BLS12381G2_MULTICODEC_IDENTIFIER, _curveToMulticodecMap);
var publicKeyJwkToDidKey = function publicKeyJwkToDidKey(publicKeyJwk) {
  var publicKey = base64url.toBuffer(publicKeyJwk.x);
  var buffer = new Uint8Array(2 + publicKey.length);
  buffer[0] = curveToMulticodecMap[publicKeyJwk.crv];
  buffer[1] = VARIABLE_INTEGER_TRAILING_BYTE;
  buffer.set(publicKey, 2);
  return "did:key:" + MULTIBASE_ENCODED_BASE58_IDENTIFIER + bs58.encode(buffer);
};

var Bls12381G1KeyPair = /*#__PURE__*/function () {
  function Bls12381G1KeyPair(options) {
    this.type = 'Bls12381G1Key2020';
    this.id = options.id;
    this.controller = options.controller;
    this.publicKeyBuffer = options.publicKeyBuffer;
    this.privateKeyBuffer = options.privateKeyBuffer;

    if (!this.controller) {
      var _this$toJsonWebKeyPai = this.toJsonWebKeyPair(false),
          publicKeyJwk = _this$toJsonWebKeyPai.publicKeyJwk;

      this.controller = publicKeyJwkToDidKey(publicKeyJwk);
    }

    if (!this.id) {
      var _this$toJsonWebKeyPai2 = this.toJsonWebKeyPair(false),
          _publicKeyJwk = _this$toJsonWebKeyPai2.publicKeyJwk;

      this.id = '#' + publicKeyJwkToDidKey(_publicKeyJwk).split('did:key:').pop();
    }
  }

  Bls12381G1KeyPair.generate = function generate() {
    try {
      return Promise.resolve(generateKeyPairs()).then(function (_ref) {
        var bls12381G1KeyPair = _ref.bls12381G1KeyPair;

        var _toJsonWebKeyPair2 = toJsonWebKeyPair(bls12381G1KeyPair),
            publicKeyJwk = _toJsonWebKeyPair2.publicKeyJwk;

        bls12381G1KeyPair.controller = publicKeyJwkToDidKey(publicKeyJwk);
        bls12381G1KeyPair.id = '#' + bls12381G1KeyPair.controller.split('did:key:').pop();
        return new Bls12381G1KeyPair({
          id: bls12381G1KeyPair.id,
          controller: bls12381G1KeyPair.controller,
          publicKeyBuffer: bs58.decode(bls12381G1KeyPair.publicKeyBase58),
          privateKeyBuffer: bs58.decode(bls12381G1KeyPair.privateKeyBase58)
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Bls12381G1KeyPair.fromFingerprint = function fromFingerprint(_ref2) {
    var fingerprint = _ref2.fingerprint;

    try {
      var _fingerprintToJsonWeb = fingerprintToJsonWebKeyPair(fingerprint),
          bls12381G1KeyPair = _fingerprintToJsonWeb.bls12381G1KeyPair;

      return Promise.resolve(new Bls12381G1KeyPair({
        id: bls12381G1KeyPair.id,
        controller: bls12381G1KeyPair.controller,
        publicKeyBuffer: base64url.toBuffer(bls12381G1KeyPair.publicKeyJwk.x)
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Bls12381G1KeyPair.from = function from(options) {
    try {
      if (options.type === 'JsonWebKey2020') {
        var opts = {
          id: options.id,
          controller: options.controller,
          publicKeyBuffer: base64url.toBuffer(options.publicKeyJwk.x)
        };

        if (options.privateKeyJwk) {
          opts.privateKeyBuffer = base64url.toBuffer(options.privateKeyJwk.d);
        }

        return Promise.resolve(new Bls12381G1KeyPair(opts));
      }

      if (options.type === 'Bls12381G1Key2020') {
        var _opts = {
          id: options.id,
          controller: options.controller,
          publicKeyBuffer: bs58.decode(options.publicKeyBase58)
        };

        if (options.privateKeyBase58) {
          _opts.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
        }

        return Promise.resolve(new Bls12381G1KeyPair(_opts));
      }

      throw new Error('unsuported key type');
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _proto = Bls12381G1KeyPair.prototype;

  _proto.fingerprint = function fingerprint() {
    var _this$toJsonWebKeyPai3 = this.toJsonWebKeyPair(false),
        publicKeyJwk = _this$toJsonWebKeyPai3.publicKeyJwk;

    return publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop();
  };

  _proto.toKeyPair = function toKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var kp = {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (exportPrivateKey) {
      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return kp;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair$1(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var result = toJsonWebKeyPair(this.toKeyPair(exportPrivateKey));

    return result;
  };

  _proto.verifier = function verifier() {
    var key = new mattr.Bls12381G1KeyPair({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    });
    return key.verifier();
  };

  _proto.signer = function signer() {
    var key = new mattr.Bls12381G1KeyPair({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer),
      privateKeyBase58: bs58.encode(this.privateKeyBuffer)
    });
    return key.signer();
  };

  return Bls12381G1KeyPair;
}();

var Bls12381G2KeyPair = /*#__PURE__*/function () {
  function Bls12381G2KeyPair(options) {
    this.type = 'Bls12381G2Key2020';
    this.id = options.id;
    this.controller = options.controller;
    this.publicKeyBuffer = options.publicKeyBuffer;
    this.privateKeyBuffer = options.privateKeyBuffer;

    if (!this.controller) {
      var _this$toJsonWebKeyPai = this.toJsonWebKeyPair(false),
          publicKeyJwk = _this$toJsonWebKeyPai.publicKeyJwk;

      this.controller = publicKeyJwkToDidKey(publicKeyJwk);
    }

    if (!this.id) {
      var _this$toJsonWebKeyPai2 = this.toJsonWebKeyPair(false),
          _publicKeyJwk = _this$toJsonWebKeyPai2.publicKeyJwk;

      this.id = '#' + publicKeyJwkToDidKey(_publicKeyJwk).split('did:key:').pop();
    }
  }

  Bls12381G2KeyPair.generate = function generate() {
    try {
      return Promise.resolve(generateKeyPairs()).then(function (_ref) {
        var bls12381G2KeyPair = _ref.bls12381G2KeyPair;

        var _toJsonWebKeyPair2 = toJsonWebKeyPair(bls12381G2KeyPair),
            publicKeyJwk = _toJsonWebKeyPair2.publicKeyJwk;

        bls12381G2KeyPair.controller = publicKeyJwkToDidKey(publicKeyJwk);
        bls12381G2KeyPair.id = '#' + bls12381G2KeyPair.controller.split('did:key:').pop();
        return new Bls12381G2KeyPair({
          id: bls12381G2KeyPair.id,
          controller: bls12381G2KeyPair.controller,
          publicKeyBuffer: bs58.decode(bls12381G2KeyPair.publicKeyBase58),
          privateKeyBuffer: bs58.decode(bls12381G2KeyPair.privateKeyBase58)
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Bls12381G2KeyPair.fromFingerprint = function fromFingerprint(_ref2) {
    var fingerprint = _ref2.fingerprint;

    try {
      var _fingerprintToJsonWeb = fingerprintToJsonWebKeyPair(fingerprint),
          bls12381G2KeyPair = _fingerprintToJsonWeb.bls12381G2KeyPair;

      return Promise.resolve(new Bls12381G2KeyPair({
        id: bls12381G2KeyPair.id,
        controller: bls12381G2KeyPair.controller,
        publicKeyBuffer: base64url.toBuffer(bls12381G2KeyPair.publicKeyJwk.x)
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Bls12381G2KeyPair.from = function from(options) {
    try {
      if (options.type === 'JsonWebKey2020') {
        var opts = {
          id: options.id,
          controller: options.controller,
          publicKeyBuffer: base64url.toBuffer(options.publicKeyJwk.x)
        };

        if (options.privateKeyJwk) {
          opts.privateKeyBuffer = base64url.toBuffer(options.privateKeyJwk.d);
        }

        return Promise.resolve(new Bls12381G2KeyPair(opts));
      }

      if (options.type === 'Bls12381G2Key2020') {
        var _opts = {
          id: options.id,
          controller: options.controller,
          publicKeyBuffer: bs58.decode(options.publicKeyBase58)
        };

        if (options.privateKeyBase58) {
          _opts.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
        }

        return Promise.resolve(new Bls12381G2KeyPair(_opts));
      }

      throw new Error('unsuported key type');
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _proto = Bls12381G2KeyPair.prototype;

  _proto.fingerprint = function fingerprint() {
    var _this$toJsonWebKeyPai3 = this.toJsonWebKeyPair(false),
        publicKeyJwk = _this$toJsonWebKeyPai3.publicKeyJwk;

    return publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop();
  };

  _proto.toKeyPair = function toKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var kp = {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (exportPrivateKey) {
      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return kp;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair$1(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    return toJsonWebKeyPair(this.toKeyPair(exportPrivateKey));
  };

  _proto.verifier = function verifier() {
    var key = new mattr.Bls12381G2KeyPair({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    });
    return key.verifier();
  };

  _proto.signer = function signer() {
    var key = new mattr.Bls12381G2KeyPair({
      publicKeyBase58: bs58.encode(this.publicKeyBuffer),
      privateKeyBase58: bs58.encode(this.privateKeyBuffer)
    });
    return key.signer();
  };

  return Bls12381G2KeyPair;
}();

var Bls12381KeyPairs = /*#__PURE__*/function () {
  function Bls12381KeyPairs(options) {
    this.type = 'Bls12381KeyPairs2020';
    this.id = options.id;
    this.controller = options.controller;
    this.g1KeyPair = options.g1KeyPair;
    this.g2KeyPair = options.g2KeyPair;

    if (!this.id) {
      this.id = '#' + this.fingerprint();
    }

    if (!this.controller) {
      this.controller = 'did:key:' + this.fingerprint();
    }

    this.g1KeyPair.controller = this.controller;
    this.g2KeyPair.controller = this.controller;
  }

  Bls12381KeyPairs.generate = function generate() {
    try {
      return Promise.resolve(generateKeyPairs()).then(function (_ref) {
        var bls12381G1KeyPair = _ref.bls12381G1KeyPair,
            bls12381G2KeyPair = _ref.bls12381G2KeyPair;
        var options = {
          id: '',
          controller: '',
          g1KeyPair: new Bls12381G1KeyPair({
            id: bls12381G1KeyPair.id,
            publicKeyBuffer: bs58.decode(bls12381G1KeyPair.publicKeyBase58),
            privateKeyBuffer: bs58.decode(bls12381G1KeyPair.privateKeyBase58)
          }),
          g2KeyPair: new Bls12381G2KeyPair({
            id: bls12381G2KeyPair.id,
            publicKeyBuffer: bs58.decode(bls12381G2KeyPair.publicKeyBase58),
            privateKeyBuffer: bs58.decode(bls12381G2KeyPair.privateKeyBase58)
          })
        };
        return new Bls12381KeyPairs(options);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Bls12381KeyPairs.fromFingerprint = function fromFingerprint(_ref2) {
    var fingerprint = _ref2.fingerprint;

    try {
      var _exit2 = false;

      var _temp3 = function _temp3(_result) {
        if (_exit2) return _result;

        if (fingerprint.indexOf('z3t') === 0) {
          return Bls12381G1KeyPair.fromFingerprint({
            fingerprint: fingerprint
          });
        }

        if (fingerprint.indexOf('zUC') === 0) {
          return Bls12381G2KeyPair.fromFingerprint({
            fingerprint: fingerprint
          });
        }

        throw new Error('Bls12381KeyPairs only supports g1, g2 and g1 and g2 mulicodec fingerprints.');
      };

      var _temp4 = function () {
        if (fingerprint.indexOf('z5Tc') === 0) {
          var _fingerprintToJsonWeb = fingerprintToJsonWebKeyPair(fingerprint),
              bls12381G1KeyPair = _fingerprintToJsonWeb.bls12381G1KeyPair,
              bls12381G2KeyPair = _fingerprintToJsonWeb.bls12381G2KeyPair;

          delete bls12381G1KeyPair.id;
          delete bls12381G2KeyPair.id;
          var controller = 'did:key:' + fingerprint;
          bls12381G1KeyPair.controller = controller;
          bls12381G2KeyPair.controller = controller;
          _exit2 = true;
          return Promise.resolve(Bls12381G1KeyPair.from(bls12381G1KeyPair)).then(function (_Bls12381G1KeyPair$fr) {
            return Promise.resolve(Bls12381G2KeyPair.from(bls12381G2KeyPair)).then(function (_Bls12381G2KeyPair$fr) {
              return new Bls12381KeyPairs({
                id: '#' + fingerprint,
                controller: controller,
                g1KeyPair: _Bls12381G1KeyPair$fr,
                g2KeyPair: _Bls12381G2KeyPair$fr
              });
            });
          });
        }
      }();

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _proto = Bls12381KeyPairs.prototype;

  _proto.fingerprint = function fingerprint() {
    var g1Buffer = this.g1KeyPair.publicKeyBuffer;
    var g2Buffer = this.g2KeyPair.publicKeyBuffer;
    var g1AndG2 = Buffer.concat([g1Buffer, g2Buffer]);
    var buffer = new Uint8Array(2 + g1AndG2.length);
    buffer[0] = BLS12381G1ANDG2_MULTICODEC_IDENTIFIER;
    buffer[1] = VARIABLE_INTEGER_TRAILING_BYTE;
    buffer.set(g1AndG2, 2);
    return "" + MULTIBASE_ENCODED_BASE58_IDENTIFIER + bs58.encode(buffer);
  };

  _proto["export"] = function _export(exportPrivate) {
    if (exportPrivate === void 0) {
      exportPrivate = false;
    }

    return {
      fingerprint: this.fingerprint(),
      g1: this.g1KeyPair.toJsonWebKeyPair(exportPrivate),
      g2: this.g2KeyPair.toJsonWebKeyPair(exportPrivate)
    };
  };

  return Bls12381KeyPairs;
}();

var getVerificationMethod = function getVerificationMethod(instance, contentType) {
  if (contentType === void 0) {
    contentType = 'application/did+ld+json';
  }

  switch (contentType) {
    case 'application/did+json':
      {
        return instance.toJsonWebKeyPair();
      }

    case 'application/did+cbor':
      {
        return instance.toJsonWebKeyPair();
      }

    case 'application/did+ld+json':
      {
        return instance.toKeyPair();
      }
  }

  throw new Error('This implementation of did:key for bls12381 does not support: ' + contentType);
};
var keyToDidDoc = function keyToDidDoc(didKeyPairInstance, contentType) {
  if (contentType === void 0) {
    contentType = 'application/did+ld+json';
  }

  try {
    var verificationRelationships = {
      verificationMethod: []
    };
    var did = "did:key:" + didKeyPairInstance.fingerprint();

    if (didKeyPairInstance.type === 'Bls12381KeyPairs2020') {
      var g1 = getVerificationMethod(didKeyPairInstance.g1KeyPair, contentType);
      var g2 = getVerificationMethod(didKeyPairInstance.g2KeyPair, contentType);
      verificationRelationships.verificationMethod.push(g1);
      verificationRelationships.verificationMethod.push(g2);
      verificationRelationships = _extends({}, verificationRelationships, {
        authentication: [g1.id, g2.id],
        assertionMethod: [g1.id, g2.id],
        capabilityInvocation: [g1.id, g2.id],
        capabilityDelegation: [g1.id, g2.id]
      });
    } else {
      var vm = getVerificationMethod(didKeyPairInstance, contentType);
      verificationRelationships.verificationMethod.push(vm);
      verificationRelationships = _extends({}, verificationRelationships, {
        authentication: [vm.id],
        assertionMethod: [vm.id],
        capabilityInvocation: [vm.id],
        capabilityDelegation: [vm.id]
      });
    }

    var didDocument = _extends({
      '@context': ['https://www.w3.org/ns/did/v1', 'https://ns.did.ai/transmute/v1', {
        '@base': did
      }],
      id: did
    }, verificationRelationships);

    return Promise.resolve(didDocument);
  } catch (e) {
    return Promise.reject(e);
  }
};

var getGet = function getGet(resolve) {
  var get = function get(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        did = _ref.did,
        url = _ref.url;

    try {
      did = did || url;

      if (!did) {
        throw new TypeError('"did" must be a string.');
      }

      return Promise.resolve(resolve(did)).then(function (result) {
        return result.didDocument;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return get;
};
var getResolve = function getResolve() {
  var resolve = function resolve(didUri, resolutionMetaData) {
    if (resolutionMetaData === void 0) {
      resolutionMetaData = {
        accept: 'application/did+ld+json'
      };
    }

    try {
      var fingerprint = didUri.split('#')[0].split('did:key:').pop();
      return Promise.resolve(Bls12381KeyPairs.fromFingerprint({
        fingerprint: fingerprint
      })).then(function (publicKey) {
        return Promise.resolve(keyToDidDoc(publicKey, resolutionMetaData.accept)).then(function (_keyToDidDoc) {
          var didResolutionResponse = {
            '@context': 'https://w3id.org/did-resolution/v1',
            didDocument: _keyToDidDoc,
            didDocumentMetadata: {
              'content-type': resolutionMetaData.accept
            },
            didResolutionMetadata: {}
          };
          return didResolutionResponse;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return resolve;
};
var resolve = /*#__PURE__*/getResolve();
var get = /*#__PURE__*/getGet(resolve);

var driver = {
  __proto__: null,
  getGet: getGet,
  getResolve: getResolve,
  resolve: resolve,
  get: get
};

exports.Bls12381G1KeyPair = Bls12381G1KeyPair;
exports.Bls12381G2KeyPair = Bls12381G2KeyPair;
exports.Bls12381KeyPairs = Bls12381KeyPairs;
exports.driver = driver;
//# sourceMappingURL=did-key-bls12381.cjs.development.js.map
