{"version":3,"file":"did-key.js.cjs.production.min.js","sources":["../src/resolver.ts"],"sourcesContent":["import { driver as ed25519Driver } from '@transmute/did-key-ed25519';\nimport { driver as x25519Driver } from '@transmute/did-key-x25519';\nimport { driver as bls12381Driver } from '@transmute/did-key-bls12381';\nimport { driver as secp256k1Driver } from '@transmute/did-key-secp256k1';\nimport { driver as didWebDriver } from '@transmute/did-key-web-crypto';\n\nconst prefixToDriverMap: any = {\n  z6M: ed25519Driver,\n  z6L: x25519Driver,\n  zUC: bls12381Driver, //g2\n  z3t: bls12381Driver, //g1\n  z5T: bls12381Driver, //g1andg2\n  zQ3: secp256k1Driver,\n  zru: didWebDriver,\n  zFw: didWebDriver,\n  zWG: didWebDriver,\n};\n\nexport const resolver = {\n  resolve: async (\n    didUrl: string,\n    resolutionMetaData: any = { accept: 'application/did+ld+json' }\n  ) => {\n    if (didUrl.indexOf('did:key:') !== 0) {\n      throw new Error('did must be of method did:key.');\n    }\n    const idchar: any = didUrl.split('did:key:').pop();\n    const encodedType = idchar.substring(0, 3);\n    if (prefixToDriverMap[encodedType]) {\n      const result = await prefixToDriverMap[encodedType].resolve(\n        didUrl,\n        resolutionMetaData\n      );\n      return result;\n    } else {\n      throw new Error('Unknown DID Key type: ' + encodedType);\n    }\n  },\n};\n"],"names":["prefixToDriverMap","z6M","ed25519Driver","z6L","x25519Driver","zUC","bls12381Driver","z3t","z5T","zQ3","secp256k1Driver","zru","didWebDriver","zFw","zWG","resolve","didUrl","resolutionMetaData","accept","indexOf","Error","encodedType","split","pop","substring"],"mappings":"qRAMMA,EAAyB,CAC7BC,IAAKC,SACLC,IAAKC,SACLC,IAAKC,SACLC,IAAKD,SACLE,IAAKF,SACLG,IAAKC,SACLC,IAAKC,SACLC,IAAKD,SACLE,IAAKF,2BAGiB,CACtBG,iBACEC,EACAC,YAAAA,IAAAA,EAA0B,CAAEC,OAAQ,mCAED,IAA/BF,EAAOG,QAAQ,kBACX,IAAIC,MAAM,sCAGZC,EADcL,EAAOM,MAAM,YAAYC,MAClBC,UAAU,EAAG,MACpCxB,EAAkBqB,0BACCrB,EAAkBqB,GAAaN,QAClDC,EACAC,UAII,IAAIG,MAAM,yBAA2BC"}