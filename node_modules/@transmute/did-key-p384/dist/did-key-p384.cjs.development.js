'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var crypto$1 = _interopDefault(require('crypto'));
var canonicalize = _interopDefault(require('canonicalize'));
var base64url = _interopDefault(require('base64url'));
var bs58 = require('bs58');
var nodeWebcryptoOssl = require('node-webcrypto-ossl');

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var getKid = function getKid(jwk) {
  var digest = crypto$1.createHash('sha256').update(canonicalize({
    crv: jwk.crv,
    x: jwk.x,
    y: jwk.y,
    kty: jwk.kty
  })).digest();
  return base64url.encode(Buffer.from(digest));
};
var publicKeyJwkToPublicKeyBase58 = function publicKeyJwkToPublicKeyBase58(publicKeyJwk) {
  var publicKeyBuffer = Buffer.concat([base64url.toBuffer(publicKeyJwk.x), base64url.toBuffer(publicKeyJwk.y)]);
  return bs58.encode(publicKeyBuffer);
};
var publicKeyBase58toPublicKeyJwk = function publicKeyBase58toPublicKeyJwk(publicKeyBase58) {
  var buffer = bs58.decode(publicKeyBase58);
  var jwk = {
    crv: 'P-384',
    x: base64url.encode(buffer.slice(0, 48)),
    y: base64url.encode(buffer.slice(48, 96)),
    kty: 'EC'
  };
  return _extends({}, jwk, {
    kid: getKid(jwk)
  });
};
var privateKeyJwkToPrivateKeyBase58 = function privateKeyJwkToPrivateKeyBase58(privateKeyJwk) {
  return bs58.encode(base64url.toBuffer(privateKeyJwk.d));
};
var privateKeyBase58toPrivateKeyJwk = function privateKeyBase58toPrivateKeyJwk(privateKeyBase58, publicKeyBase58) {
  var publicKeyJwk = publicKeyBase58toPublicKeyJwk(publicKeyBase58);
  return _extends({}, publicKeyJwk, {
    d: base64url.encode(bs58.decode(privateKeyBase58))
  });
};

var keyUtils = {
  __proto__: null,
  getKid: getKid,
  publicKeyJwkToPublicKeyBase58: publicKeyJwkToPublicKeyBase58,
  publicKeyBase58toPublicKeyJwk: publicKeyBase58toPublicKeyJwk,
  privateKeyJwkToPrivateKeyBase58: privateKeyJwkToPrivateKeyBase58,
  privateKeyBase58toPrivateKeyJwk: privateKeyBase58toPrivateKeyJwk
};

function isNodejs() {
  return typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node !== 'undefined';
}

var crypto;

if (isNodejs()) {
  crypto = /*#__PURE__*/new nodeWebcryptoOssl.Crypto();
} else {
  crypto = window.crypto;
}

var generate = function generate() {
  try {
    return Promise.resolve(crypto.subtle.generateKey({
      name: 'ECDSA',
      namedCurve: 'P-384'
    }, true, ['sign', 'verify'])).then(function (key) {
      return Promise.resolve(crypto.subtle.exportKey('jwk', key.publicKey)).then(function (publicKeyJwk) {
        return Promise.resolve(crypto.subtle.exportKey('jwk', key.privateKey)).then(function (privateKeyJwk) {
          return {
            publicKeyJwk: publicKeyJwk,
            privateKeyJwk: privateKeyJwk
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var sign = function sign(message, privateKeyJwk) {
  try {
    return Promise.resolve(crypto.subtle.importKey('jwk', privateKeyJwk, {
      name: 'ECDSA',
      namedCurve: 'P-384'
    }, true, ['sign'])).then(function (privateKey) {
      return Promise.resolve(crypto.subtle.sign({
        name: 'ECDSA',
        hash: {
          name: 'SHA-384'
        }
      }, privateKey, message)).then(function (signature) {
        return new Uint8Array(signature);
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify = function verify(message, signature, publicKeyJwk) {
  try {
    return Promise.resolve(crypto.subtle.importKey('jwk', publicKeyJwk, {
      name: 'ECDSA',
      namedCurve: 'P-384'
    }, true, ['verify'])).then(function (publicKey) {
      return crypto.subtle.verify({
        name: 'ECDSA',
        hash: {
          name: 'SHA-384'
        }
      }, publicKey, signature, message);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var deriveSecret = function deriveSecret(privateKeyJwk, publicKeyJwk) {
  try {
    return Promise.resolve(crypto.subtle.importKey('jwk', privateKeyJwk, {
      name: 'ECDH',
      namedCurve: 'P-384'
    }, true, ['deriveBits'])).then(function (privateKey) {
      return Promise.resolve(crypto.subtle.importKey('jwk', publicKeyJwk, {
        name: 'ECDH',
        namedCurve: 'P-384'
      }, true, ['deriveBits'])).then(function (publicKey) {
        return Promise.resolve(crypto.subtle.deriveBits({
          name: 'ECDH',
          "public": publicKey
        }, privateKey, 256)).then(function (result) {
          return new Uint8Array(result);
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var sign$1 = function sign$1(privateKeyJwk, payload, header) {
  if (header === void 0) {
    header = {
      alg: 'ES384'
    };
  }

  try {
    var toBeSigned = base64url.encode(JSON.stringify(header)) + "." + base64url.encode(JSON.stringify(payload));
    return Promise.resolve(sign(new Uint8Array(Buffer.from(toBeSigned)), privateKeyJwk)).then(function (signature) {
      return toBeSigned + "." + base64url.encode(Buffer.from(signature));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify$1 = function verify$1(publicKeyJwk, jws) {
  try {
    var _jws$split = jws.split('.'),
        encodedHeader = _jws$split[0],
        encodedPayload = _jws$split[1],
        encodedSignature = _jws$split[2];

    var toBeSigned = [encodedHeader, encodedPayload].join('.');
    var verified = false;
    return Promise.resolve(verify(new Uint8Array(Buffer.from(toBeSigned)), new Uint8Array(base64url.toBuffer(encodedSignature)), publicKeyJwk)).then(function (_help$verify) {
      verified = _help$verify;
      return verified;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var signDetached = function signDetached(privateKeyJwk, payload, header) {
  if (header === void 0) {
    header = {
      alg: 'ES384'
    };
  }

  try {
    var encodedHeader = base64url.encode(JSON.stringify(header));
    var toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);
    return Promise.resolve(sign(new Uint8Array(toBeSignedBuffer), privateKeyJwk)).then(function (signature) {
      return encodedHeader + ".." + base64url.encode(Buffer.from(signature));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyDetached = function verifyDetached(publicKeyJwk, jws, payload) {
  try {
    var _jws$split2 = jws.split('..'),
        encodedHeader = _jws$split2[0],
        encodedSignature = _jws$split2[1];

    var toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);
    var verified = false;
    return Promise.resolve(verify(new Uint8Array(Buffer.from(toBeSignedBuffer)), new Uint8Array(base64url.toBuffer(encodedSignature)), publicKeyJwk)).then(function (_help$verify2) {
      verified = _help$verify2;
      return verified;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var ES384 = {
  __proto__: null,
  sign: sign$1,
  verify: verify$1,
  signDetached: signDetached,
  verifyDetached: verifyDetached
};

var verificationMethodType = 'JsonWebKey2020';

var P384KeyPair = /*#__PURE__*/function () {
  function P384KeyPair(options) {
    this.type = verificationMethodType;
    this.id = options.id;
    this.controller = options.controller;
    this.type = options.type || 'JsonWebKey2020';
    this.publicKeyBuffer = options.publicKeyBuffer;
    this.privateKeyBuffer = options.privateKeyBuffer;

    if (options.publicKeyBase58) {
      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);
    }

    if (options.privateKeyBase58) {
      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
    }

    if (options.publicKeyJwk) {
      this.publicKeyBuffer = Buffer.concat([base64url.toBuffer(options.publicKeyJwk.x), base64url.toBuffer(options.publicKeyJwk.y)]);
    }

    if (options.privateKeyJwk) {
      this.publicKeyBuffer = Buffer.concat([base64url.toBuffer(options.privateKeyJwk.x), base64url.toBuffer(options.privateKeyJwk.y)]);
      this.privateKeyBuffer = Buffer.concat([base64url.toBuffer(options.privateKeyJwk.d)]);
    }

    var publicKeyBase58 = bs58.encode(this.publicKeyBuffer);
    var fingerprint = P384KeyPair.fingerprintFromPublicKey({
      publicKeyBase58: publicKeyBase58
    });

    if (!this.id) {
      this.id = '#' + fingerprint;
    }

    if (!this.controller) {
      this.controller = 'did:key:' + fingerprint;
    }
  }

  P384KeyPair.fingerprintFromPublicKey = function fingerprintFromPublicKey(_ref) {
    var publicKeyBase58 = _ref.publicKeyBase58;
    var pubkeyBytes = bs58.decode(publicKeyBase58);
    var buffer = new Uint8Array(2 + pubkeyBytes.length); // See https://github.com/multiformats/multicodec/blob/master/table.csv
    // 0xef is P-384 public key

    buffer[0] = 0xef; //

    buffer[1] = 0x01;
    buffer.set(pubkeyBytes, 2); // prefix with `z` to indicate multi-base base58btc encoding

    return "z" + bs58.encode(buffer);
  };

  P384KeyPair.fromFingerprint = function fromFingerprint(_ref2) {
    var fingerprint = _ref2.fingerprint;
    // skip leading `z` that indicates base58 encoding
    var buffer = bs58.decode(fingerprint.substr(1)); // https://github.com/multiformats/multicodec/blob/master/table.csv#L77

    if (buffer[0] === 0xef && buffer[1] === 0x01) {
      var publicKeyBase58 = bs58.encode(buffer.slice(2));
      var did = "did:key:" + P384KeyPair.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      var keyId = "#" + P384KeyPair.fingerprintFromPublicKey({
        publicKeyBase58: publicKeyBase58
      });
      return new P384KeyPair({
        id: keyId,
        controller: did,
        publicKeyBase58: publicKeyBase58
      });
    }

    throw new Error("Unsupported Fingerprint Type: " + fingerprint);
  };

  var _proto = P384KeyPair.prototype;

  _proto.addEncodedPublicKey = function addEncodedPublicKey(publicKeyNode) {
    publicKeyNode.publicKeyBase58 = bs58.encode(this.publicKeyBuffer);
    return publicKeyNode;
  };

  _proto.publicNode = function publicNode(_temp) {
    var _ref3 = _temp === void 0 ? {} : _temp,
        _ref3$controller = _ref3.controller,
        controller = _ref3$controller === void 0 ? this.controller : _ref3$controller;

    var publicNode = {
      id: this.id,
      type: this.type
    };

    if (controller) {
      publicNode.controller = controller;
    }

    this.addEncodedPublicKey(publicNode); // Subclass-specific

    return publicNode;
  };

  _proto.toJwk = function toJwk(exportPrivate) {
    if (exportPrivate === void 0) {
      exportPrivate = false;
    }

    if (exportPrivate) {
      return privateKeyBase58toPrivateKeyJwk(bs58.encode(this.privateKeyBuffer), bs58.encode(this.publicKeyBuffer));
    }

    return publicKeyBase58toPublicKeyJwk(bs58.encode(this.publicKeyBuffer));
  };

  _proto.toVerificationMethod = function toVerificationMethod() {
    var publicKeyJwk = this.toJwk();
    delete publicKeyJwk.kid;
    return {
      id: this.id,
      type: verificationMethodType,
      controller: this.controller,
      publicKeyJwk: publicKeyJwk
    };
  };

  _proto.fingerprint = function fingerprint() {
    var publicKeyBase58 = bs58.encode(this.publicKeyBuffer);
    return P384KeyPair.fingerprintFromPublicKey({
      publicKeyBase58: publicKeyBase58
    });
  };

  _proto.signer = function signer() {
    if (!this.privateKeyBuffer) {
      return {
        sign: function sign() {
          try {
            throw new Error('No private key to sign with.');
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    }

    var privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    var publicKeyBase58 = bs58.encode(this.publicKeyBuffer);
    var privateKeyJwk = privateKeyBase58toPrivateKeyJwk(privateKeyBase58, publicKeyBase58);
    return {
      sign: function sign$1(_ref4) {
        var data = _ref4.data;

        try {
          var signature = sign(data, privateKeyJwk);
          return Promise.resolve(signature);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  _proto.verifier = function verifier() {
    if (!this.publicKeyBuffer) {
      return {
        verify: function verify() {
          try {
            throw new Error('No public key to verify with.');
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    }

    var publicKeyBase58 = bs58.encode(this.publicKeyBuffer);
    var publicKeyJwk = publicKeyBase58toPublicKeyJwk(publicKeyBase58);
    return {
      verify: function verify$1(_ref5) {
        var data = _ref5.data,
            signature = _ref5.signature;

        try {
          return Promise.resolve(verify(data, signature, publicKeyJwk));
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
  };

  _proto.deriveSecret = function deriveSecret$1(_ref6) {
    var publicKey = _ref6.publicKey;

    try {
      var _this2 = this;

      var privateKeyBase58 = bs58.encode(_this2.privateKeyBuffer);
      var publicKeyBase58 = bs58.encode(_this2.publicKeyBuffer);
      var privateKeyJwk = privateKeyBase58toPrivateKeyJwk(privateKeyBase58, publicKeyBase58);
      return Promise.resolve(deriveSecret(privateKeyJwk, publicKey.publicKeyJwk));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _createClass(P384KeyPair, [{
    key: "publicKey",
    get: function get() {
      return bs58.encode(this.publicKeyBuffer);
    }
  }, {
    key: "privateKey",
    get: function get() {
      return bs58.encode(this.privateKeyBuffer);
    }
  }]);

  return P384KeyPair;
}();

P384KeyPair.from = function (options) {
  try {
    return Promise.resolve(new P384KeyPair(_extends({}, options)));
  } catch (e) {
    return Promise.reject(e);
  }
};

P384KeyPair.generate = function () {
  try {
    return Promise.resolve(generate()).then(function (key) {
      return P384KeyPair.from(key);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var computeKeyId = function computeKeyId(_ref) {
  var key = _ref.key;

  try {
    return Promise.resolve("did:key:" + key.fingerprint() + "#" + key.fingerprint());
  } catch (e) {
    return Promise.reject(e);
  }
};
var keyToDidDoc = function keyToDidDoc(secp256k1Key) {
  var did = "did:key:" + secp256k1Key.fingerprint();
  var publicKeyJwk = secp256k1Key.toJwk();
  var keyId = "#" + publicKeyJwk.kid;
  delete publicKeyJwk.kid;
  return {
    '@context': ['https://www.w3.org/ns/did/v1', {
      '@base': did
    }],
    id: did,
    publicKey: [{
      id: keyId,
      type: secp256k1Key.type,
      controller: did,
      publicKeyJwk: publicKeyJwk
    }],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId],
    keyAgreement: [keyId]
  };
};
var get = function get(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      did = _ref2.did,
      url = _ref2.url;

  try {
    did = did || url;

    if (!did) {
      throw new TypeError('"did" must be a string.');
    }

    var fingerprint = did.split('#')[0].split('did:key:').pop();
    return Promise.resolve(P384KeyPair.fromFingerprint({
      fingerprint: fingerprint
    })).then(function (publicKey) {
      var didDoc = keyToDidDoc(publicKey);
      return didDoc;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var driver = {
  __proto__: null,
  computeKeyId: computeKeyId,
  keyToDidDoc: keyToDidDoc,
  get: get
};

exports.ES384 = ES384;
exports.P384KeyPair = P384KeyPair;
exports.driver = driver;
exports.keyUtils = keyUtils;
//# sourceMappingURL=did-key-p384.cjs.development.js.map
